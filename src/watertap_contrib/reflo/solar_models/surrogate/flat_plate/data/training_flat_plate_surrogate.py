import os
from os.path import join, dirname
import sys
import re
import numpy as np
import pandas as pd
from io import StringIO
import matplotlib.pyplot as plt
import itertools
from pyomo.environ import ConcreteModel, SolverFactory, value, Var, Objective, maximize
from pyomo.common.timing import TicTocTimer
from idaes.core.surrogate.sampling.data_utils import split_training_validation
from idaes.core.surrogate.pysmo_surrogate import PysmoRBFTrainer, PysmoSurrogate
from idaes.core.surrogate.surrogate_block import SurrogateBlock
from idaes.core import FlowsheetBlock


def create_rbf_surrogate(
    training_dataframe, input_labels, output_labels, output_filename=None, tee=False
):
    # Capture long output
    stream = StringIO()
    oldstdout = sys.stdout
    sys.stdout = stream

    # Create PySMO trainer object
    trainer = PysmoRBFTrainer(
        input_labels=input_labels,
        output_labels=output_labels,
        training_dataframe=training_dataframe,
    )

    # Set PySMO options
    trainer.config.basis_function = "gaussian"  # default = gaussian
    trainer.config.solution_method = "algebraic"  # default = algebraic
    trainer.config.regularization = True  # default = True

    # Train surrogate
    rbf_train = trainer.train_surrogate()

    # Remove autogenerated 'solution.pickle' file
    try:
        os.remove("solution.pickle")
    except FileNotFoundError:
        pass
    except Exception as e:
        raise e

    # Create callable surrogate object
    xmin, xmax = [100, 0, 50], [1000, 26, 100]
    input_bounds = {
        input_labels[i]: (xmin[i], xmax[i]) for i in range(len(input_labels))
    }
    rbf_surr = PysmoSurrogate(rbf_train, input_labels, output_labels, input_bounds)

    # Save model to JSON
    if output_filename is not None:
        model = rbf_surr.save_to_file(output_filename, overwrite=True)

    # Revert back to standard output
    sys.stdout = oldstdout

    if tee:
        # Display first 50 lines and last 50 lines of output
        celloutput = stream.getvalue().split("\n")
        for line in celloutput[:50]:
            print(line)
        print(".")
        print(".")
        print(".")
        for line in celloutput[-50:]:
            print(line)

    return rbf_surr


def get_training_validation(dataset_filename, n_samples, training_fraction):
    pkl_data = pd.read_pickle(dataset_filename)
    data = pkl_data.sample(n=n_samples)
    data_training, data_validation = split_training_validation(
        data, training_fraction, seed=len(data)
    )  # each has all columns
    return data_training, data_validation


def _parity_residual_plots(true_values, modeled_values, label=None, **kwargs):
    axis_fontsize = 18
    title_fontsize = 22

    if "axis_fontsize" in kwargs.keys():
        axis_fontsize = kwargs["axis_fontsize"]
    if "title_fontsize" in kwargs.keys():
        title_fontsize = kwargs["title_fontsize"]

    fig1 = plt.figure(figsize=(13, 6), tight_layout=True)
    if label is not None:
        fig1.suptitle(label, fontsize=title_fontsize)
    ax = fig1.add_subplot(121)
    ax.plot(true_values, true_values, "-")
    ax.plot(true_values, modeled_values, "o")
    ax.set_xlabel(r"True data", fontsize=axis_fontsize)
    ax.set_ylabel(r"Surrogate values", fontsize=axis_fontsize)
    ax.set_title(r"Parity plot", fontsize=axis_fontsize)

    ax2 = fig1.add_subplot(122)
    ax2.plot(
        true_values,
        true_values - modeled_values,
        "s",
        mfc="w",
        mec="m",
        ms=6,
    )
    ax2.axhline(y=0, xmin=0, xmax=1)
    ax2.set_xlabel(r"True data", fontsize=axis_fontsize)
    ax2.set_ylabel(r"Residuals", fontsize=axis_fontsize)
    ax2.set_title(r"Residual plot", fontsize=axis_fontsize)

    plt.show()

    return


def plot_training_validation(
    surrogate,
    data_training,
    data_validation,
    input_labels,
    output_labels,
    save_figs=False,
):
    for output_label in output_labels:
        # Output fit metrics and create parity and residual plots
        print(
            "{label}: \nR2: {r2} \nRMSE: {rmse}".format(
                label=output_label,
                r2=surrogate._trained._data[output_label].model.R2,
                rmse=surrogate._trained._data[output_label].model.rmse,
            )
        )
        training_output = surrogate.evaluate_surrogate(data_training[input_labels])
        label = re.sub(
            "[^a-zA-Z0-9 \n\.]", " ", output_label.title()
        )  # keep alphanumeric chars and make title case
        _parity_residual_plots(
            true_values=np.array(data_training[output_label]),
            modeled_values=np.array(training_output[output_label]),
            label=label,
        )
        if save_figs:
            plt.savefig("/plots/parity_training_residual_plots.png")
            plt.close()

        # Validate model using validation data
        validation_output = surrogate.evaluate_surrogate(data_validation[input_labels])
        _parity_residual_plots(
            true_values=np.array(data_validation[output_label]),
            modeled_values=np.array(validation_output[output_label]),
            label=label,
        )
        if save_figs:
            plt.savefig("/plots/parity_validation_residual_plots.png")
            plt.close()


def plot_3d(surrogate):
    """Plot 'official' saved surrogate model to show any local minima"""
    n_divisions = 15
    input_defaults = {
        "heat_load": 500,
        "hours_storage": 10,
        "temperature_hot": 70,
    }
    output_labels = ["heat_annual", "electricity_annual"]

    def eval_and_plot(x_label, y_label, z_label):
        # Eval:
        x = np.linspace(*surrogate._input_bounds[x_label], n_divisions, endpoint=True)
        y = np.linspace(*surrogate._input_bounds[y_label], n_divisions, endpoint=True)
        xx, yy = np.meshgrid(x, y)  # create combinations of x and y

        df = pd.DataFrame(
            {
                x_label: xx.flatten(),
                y_label: yy.flatten(),
            }
        )

        plot_label = ""
        other_labels = [
            label for label in input_defaults.keys() if label not in [x_label, y_label]
        ]
        for label in other_labels:
            df[label] = [input_defaults[label]] * len(df)  # repeat default value
            plot_label += f"{label} = {input_defaults[label]}, "

        output = surrogate.evaluate_surrogate(df)
        df = df.join(output)

        # Plot:
        fig = plt.figure(figsize=(8, 6))
        ax = fig.add_subplot(1, 1, 1, projection="3d")
        surf = ax.plot_trisurf(
            df[x_label], df[y_label], df[z_label], cmap=plt.cm.viridis, linewidth=0.2
        )
        ax.set_xlabel(x_label)
        ax.set_ylabel(y_label)
        ax.set_zlabel(z_label)
        ax.set_title(f"{plot_label}")
        plt.show()

    for x_label, y_label in itertools.combinations(input_defaults.keys(), 2):
        for z_label in output_labels:
            eval_and_plot(x_label, y_label, z_label)


#########################################################################################################
if __name__ == "__main__":
    create_plots = True
    dataset_filename = join(dirname(__file__), "../data/test_flat_plate_data.pkl")
    surrogate_filename = join(dirname(__file__), "../flat_plate_surrogate.json")
    n_samples = 100  # number of points to use from overall dataset
    training_fraction = 0.8
    input_labels = ["heat_load", "hours_storage", "temperature_hot"]
    output_labels = ["heat_annual", "electricity_annual"]

    # Get training and validation data
    data_training, data_validation = get_training_validation(
        dataset_filename, n_samples, training_fraction
    )

    # Create surrogate and save to file
    surrogate = create_rbf_surrogate(
        data_training, input_labels, output_labels, surrogate_filename
    )

    if create_plots:
        plot_3d(surrogate)

    # Load surrogate model from file
    surrogate = PysmoSurrogate.load_from_file(surrogate_filename)

    # Delete surrogate testing file
    # os.remove(surrogate_filename)

    # Create parity and residual plots for training and validation
    plot_training_validation(
        surrogate, data_training, data_validation, input_labels, output_labels
    )

    ### Build and run IDAES flowsheet #########################################################################################
    m = ConcreteModel()
    m.fs = FlowsheetBlock(dynamic=False)

    # create flowsheet input variables
    m.fs.heat_load = Var(
        initialize=1000, bounds=[100, 1000], doc="rated plant heat capacity in MWt"
    )
    m.fs.hours_storage = Var(
        initialize=20, bounds=[0, 26], doc="rated plant hours of storage"
    )
    m.fs.temperature_hot = Var(
        initialize=70, bounds=[50, 100], doc="hot outlet temperature"
    )

    # create flowsheet output variable
    m.fs.heat_annual = Var(
        initialize=5e9, doc="annual heat produced by the plant in kWht"
    )
    m.fs.electricity_annual = Var(
        initialize=1e9, doc="annual electricity consumed by the plant in kWht"
    )

    # create input and output variable object lists for flowsheet
    inputs = [m.fs.heat_load, m.fs.hours_storage, m.fs.temperature_hot]
    outputs = [m.fs.heat_annual, m.fs.electricity_annual]

    # capture long output
    stream = StringIO()
    oldstdout = sys.stdout
    sys.stdout = stream

    m.fs.surrogate = SurrogateBlock(concrete=True)
    m.fs.surrogate.build_model(surrogate, input_vars=inputs, output_vars=outputs)

    # revert back to standard output
    sys.stdout = oldstdout

    # fix input values and solve flowsheet
    m.fs.heat_load.fix(1000)
    m.fs.hours_storage.fix(20)
    m.fs.temperature_hot.fix(70)
    solver = SolverFactory("ipopt")
    results = solver.solve(m)

    print("\n")
    print("Heat rate = {x:.0f} MWt".format(x=value(m.fs.heat_load)))
    print("Hours of storage = {x:.1f} hrs".format(x=value(m.fs.hours_storage)))
    print("Hot outlet temperature = {x:.1f} C".format(x=value(m.fs.temperature_hot)))
    print("Annual heat output = {x:.2e} kWht".format(x=value(m.fs.heat_annual)))
    print(
        "Annual electricity input = {x:.2e} kWhe".format(
            x=value(m.fs.electricity_annual)
        )
    )

    ### Optimize the surrogate model #########################################################################################
    m.fs.heat_load.unfix()
    m.fs.hours_storage.unfix()
    m.fs.temperature_hot.unfix()
    m.fs.obj = Objective(expr=m.fs.heat_annual, sense=maximize)

    # solve the optimization
    print("\n")
    print("Optimizing annual energy...")
    tmr = TicTocTimer()
    status = solver.solve(m, tee=False)
    solve_time = tmr.toc("solve")

    print("Model status: ", status)
    print("Solve time: ", solve_time)
    print("Heat rate = {x:.0f} MWt".format(x=value(m.fs.heat_load)))
    print("Hours of storage = {x:.1f} hrs".format(x=value(m.fs.hours_storage)))
    print("Hot outlet temperature = {x:.1f} C".format(x=value(m.fs.temperature_hot)))
    print("Annual heat output = {x:.2e} kWht".format(x=value(m.fs.heat_annual)))
    print(
        "Annual electricity input = {x:.2e} kWhe".format(
            x=value(m.fs.electricity_annual)
        )
    )

    x = 1
    pass
