import os
from os.path import join, dirname
import sys
import re
import numpy as np
import pandas as pd
from io import StringIO
import matplotlib.pyplot as plt
from matplotlib import ticker
import seaborn as sns
from pyomo.environ import ConcreteModel, SolverFactory, value, Var, Objective, maximize
from pyomo.common.timing import TicTocTimer
from idaes.core.surrogate.sampling.data_utils import split_training_validation, split_training_validation_testing
from idaes.core.surrogate.pysmo_surrogate import PysmoRBFTrainer, PysmoSurrogate
from idaes.core.surrogate.surrogate_block import SurrogateBlock
from idaes.core import FlowsheetBlock
import time
dataset_filename = '/Users/zbinger/watertap-seto/src/watertap_contrib/seto/analysis/net_metering/pysam_data/dataset.pkl'
palette = ['#F0CEA0', '#2A628F', '#F2542D', '#916C80', '#A85751']
output_labels = ['annual_energy']

def get_training_validation(dataset_filename, sample_frac=1, training_fraction=0.8):
    print('Loading Training Data...\n')
    time_start = time.process_time()
    pkl_data = pd.read_pickle(dataset_filename)
    data = pkl_data.sample(n=int(sample_frac*len(pkl_data)))
    data_training, data_validation = split_training_validation(
        data, training_fraction, seed=len(data)
    )
    time_stop = time.process_time()
    print("Data Loading Time:", time_stop - time_start, "\n")
    return data_training, data_validation

def create_rbf_surrogate(
    training_dataframe, input_labels, output_labels, output_filename=None
):
    print('Creating Surrogate Model...\n')
    time_start = time.process_time()
    # Capture long output
    stream = StringIO()
    oldstdout = sys.stdout
    sys.stdout = stream

    # Create PySMO trainer object
    trainer = PysmoRBFTrainer(
        input_labels=input_labels,
        output_labels=output_labels,
        training_dataframe=training_dataframe,
    )

    # Set PySMO options
    trainer.config.basis_function = "gaussian"  # default = gaussian
    trainer.config.solution_method = "algebraic"  # default = algebraic
    trainer.config.regularization = True  # default = True

    # Train surrogate
    rbf_train = trainer.train_surrogate()

    # Remove autogenerated 'solution.pickle' file
    try:
        os.remove("solution.pickle")
    except FileNotFoundError:
        pass
    except Exception as e:
        raise e

    # Create callable surrogate object
    xmin, xmax = [0], [10000]
    input_bounds = {
        input_labels[i]: (xmin[i], xmax[i]) for i in range(len(input_labels))
    }
    rbf_surr = PysmoSurrogate(rbf_train, input_labels, output_labels, input_bounds)

    # Save model to JSON
    if output_filename is not None:
        print(f'Writing surrogate model to {output_filename}')
        model = rbf_surr.save_to_file(output_filename, overwrite=True)

    # Revert back to standard output
    sys.stdout = oldstdout

    time_stop = time.process_time()
    print("Model Training Time:", time_stop - time_start, "\n")

    return rbf_surr

def _parity_residual_plots(true_values, modeled_values, label=None):
    AXIS_FONTSIZE = 18
    TITLE_FONTSIZE = 22

    fig1 = plt.figure(figsize=(13, 6), tight_layout=True)
    if label is not None:
        fig1.suptitle(label, fontsize=TITLE_FONTSIZE)
    ax = fig1.add_subplot(121)
    ax.plot(true_values, true_values, "-")
    ax.plot(true_values, modeled_values, "o")
    ax.set_xlabel(r"True data", fontsize=AXIS_FONTSIZE)
    ax.set_ylabel(r"Surrogate values", fontsize=AXIS_FONTSIZE)
    ax.set_title(r"Parity plot", fontsize=AXIS_FONTSIZE)

    ax2 = fig1.add_subplot(122)
    ax2.plot(
        true_values,
        true_values - modeled_values,
        "s",
        mfc="w",
        mec="m",
        ms=6,
    )
    ax2.axhline(y=0, xmin=0, xmax=1)
    ax2.set_xlabel(r"True data", fontsize=AXIS_FONTSIZE)
    ax2.set_ylabel(r"Residuals", fontsize=AXIS_FONTSIZE)
    ax2.set_title(r"Residual plot", fontsize=AXIS_FONTSIZE)

    plt.show()

    return

def plot_parity(true_values, modeled_values, color='k', label=None, axes=None, title=None, R_val= None):
    data_scale = np.floor(np.log10(true_values.max()))
    data_bound = (10**data_scale)*np.ceil(true_values.max()/(10**data_scale))
    if axes == None:
        fig, ax = plt.subplots(figsize=(6,6))
    else:
        ax=axes
    ax.plot([0, data_bound], [0, data_bound], color='k', linewidth=2, linestyle='dashed', zorder=1)
    f = sns.scatterplot(x=true_values, y=modeled_values, ax=ax, s=50, alpha=0.7, facecolor=color, edgecolor='k', marker='o', zorder=2)
    if title!=None:
        ax.set_title(title, fontsize=16)
    ax.set_xlim([0,data_bound])
    ax.set_ylim([0,data_bound])
    ax.set_xlabel(f'True Values', fontsize=16)
    ax.set_ylabel(f'Model Values', fontsize=16)
    ax.tick_params(axis='x', labelsize = 16)
    ax.tick_params(axis='y', labelsize = 16)
    ax.locator_params(axis='x', nbins=5)
    ax.locator_params(axis='y', nbins=5)
    ax.ticklabel_format(axis='both',style='scientific',useMathText=True,scilimits=(0,data_scale))

    ax.annotate(f'R2 = {R_val}', (0.05*data_bound,0.9*data_bound), size=12)
    # ax.tight_layout()
    # plt.savefig(f'/Users/zbinger/watertap-seto/src/watertap_contrib/seto/solar_models/surrogate/plots/parity_plot_{label}.png', dpi=300)

def plot_training_validation(
    surrogate, data_training, data_validation, input_labels, output_labels
):
    fig, ax = plt.subplots(2,len(output_labels),figsize=(4*len(output_labels),8))
    fig.subplots_adjust(wspace=0.4, hspace=0.4)
    for idx, output_label in enumerate(output_labels):
        training_output = surrogate.evaluate_surrogate(data_training[input_labels])
        validation_output = surrogate.evaluate_surrogate(data_validation[input_labels])
        corr_matrix = np.corrcoef(data_validation[output_label], validation_output[output_label])
        corr = corr_matrix[0,1]
        r2_testing = round(corr**2,3)      
        r2_training=round(surrogate._trained._data[output_label].model.R2,3)
        rmse_training=round(surrogate._trained._data[output_label].model.rmse,3)

        label = re.sub("[^a-zA-Z0-9 \n\.]", " ", output_label.title())
        # Output fit metrics and create parity and residual plots
        print(f"{label}: \nR2: {r2_training} \nRMSE: {rmse_training}\n")
        if len(output_labels) > 1:
            train_ax = ax[0,idx]
            test_ax = ax[1,idx]
        else:
            train_ax = ax[0]
            test_ax = ax[1]
        plot_parity(
            true_values=np.array(data_training[output_label]),
            modeled_values=np.array(training_output[output_label]), color='#2A628F',
            label=output_label, axes=train_ax, title=f'{label}\n\nTraining', R_val=r2_training
        )
        plot_parity(
            true_values=np.array(data_validation[output_label]),
            modeled_values=np.array(data_validation[output_label]), color='#fc3c06',
            label=output_label, axes=test_ax, title='Testing', R_val=r2_testing
        )
    plt.tight_layout()
    plt.show()


#########################################################################################################
if __name__ == "__main__":
    data_training, data_validation = get_training_validation(dataset_filename, sample_frac=0.1, training_fraction=0.9)

    surrogate_filename = join(dirname(__file__), "pv_surrogate_testing.json")
    surrogate = create_rbf_surrogate(
        data_training, ['design_size'], output_labels, output_filename=surrogate_filename
    )
    
    # Load surrogate model from file
    surrogate = PysmoSurrogate.load_from_file(surrogate_filename)

    # Delete surrogate testing file
    # os.remove(surrogate_filename)

    selected_labels = ['annual_energy']
    # Create parity and residual plots for training and validation
    plot_training_validation(
        surrogate, data_training, data_validation, ['design_size'], selected_labels
    )