###############################################################################
# WaterTAP Copyright (c) 2021, The Regents of the University of California,
# through Lawrence Berkeley National Laboratory, Oak Ridge National
# Laboratory, National Renewable Energy Laboratory, and National Energy
# Technology Laboratory (subject to receipt of any required approvals from
# the U.S. Dept. of Energy). All rights reserved.
#
# Please see the files COPYRIGHT.md and LICENSE.md for full copyright and license
# information, respectively. These files are also available online at the URL
# "https://github.com/watertap-org/watertap/"
#
###############################################################################

import os
import sys
from io import StringIO

from pyomo.environ import (
    Var,
    Constraint,
    Suffix,
    units as pyunits,
    check_optimal_termination,
)

from idaes.core import declare_process_block_class
import idaes.core.util.scaling as iscale

from watertap_contrib.seto.core import SolarEnergyBaseData
from idaes.core.solvers.get_solver import get_solver
from idaes.core.util.exceptions import InitializationError

import idaes.logger as idaeslog

_log = idaeslog.getLogger(__name__)

__author__ = "Matthew Boyd, Kurban Sitterley"


@declare_process_block_class("TroughSurrogate")
class TroughSurrogateData(SolarEnergyBaseData):
    """
    Surrogate model for trough.
    """

    def build(self):
        super().build()

        self._tech_type = "trough"

        self.heat_load = Var(
            initialize=1000,
            bounds=[100, 1000],
            units=pyunits.MW,
            doc="Rated plant heat capacity in MWt",
        )

        self.hours_storage = Var(
            initialize=20,
            bounds=[0, 26],
            units=pyunits.hour,
            doc="Rated plant hours of storage",
        )

        self.heat_annual = Var(
            initialize=1000,
            units=pyunits.kWh,
            doc="Annual heat generated by trough",
        )

        self.electricity_annual = Var(
            initialize=20,
            units=pyunits.kWh,
            doc="Annual electricity consumed by trough",
        )

        self.surrogate_inputs = [self.heat_load, self.hours_storage]
        self.surrogate_outputs = [self.heat_annual, self.electricity_annual]

        self.input_labels = ["heat_load", "hours_storage"]
        self.output_labels = ["heat_annual", "electricity_annual"]

        if self.config.surrogate_model_file:
            self.surrogate_file = os.path.join(
                os.path.dirname(__file__), self.config.surrogate_model_file
            )

        else:
            self.surrogate_file = os.path.join(
                os.path.dirname(__file__), "trough_surrogate.json"
            )

        self._load_surrogate()

        self.heat_constraint = Constraint(
            expr=self.heat_annual
            == self.heat * pyunits.convert(1 * pyunits.year, to_units=pyunits.hour)
        )

        self.electricity_constraint = Constraint(
            expr=self.electricity_annual
            == self.electricity
            * pyunits.convert(1 * pyunits.year, to_units=pyunits.hour)
        )

        self.dataset_filename = os.path.join(
            os.path.dirname(__file__), "data/trough_data.pkl"
        )

    def calculate_scaling_factors(self):

        if iscale.get_scaling_factor(self.hours_storage) is None:
            sf = iscale.get_scaling_factor(self.hours_storage, default=1)
            iscale.set_scaling_factor(self.hours_storage, sf)

        if iscale.get_scaling_factor(self.heat_load) is None:
            sf = iscale.get_scaling_factor(self.heat_load, default=1e-2, warning=True)
            iscale.set_scaling_factor(self.heat_load, sf)

        if iscale.get_scaling_factor(self.heat_annual) is None:
            sf = iscale.get_scaling_factor(self.heat_annual, default=1e-4, warning=True)
            iscale.set_scaling_factor(self.heat_annual, sf)

        if iscale.get_scaling_factor(self.heat) is None:
            sf = iscale.get_scaling_factor(self.heat, default=1e-4, warning=True)
            iscale.set_scaling_factor(self.heat, sf)

        if iscale.get_scaling_factor(self.electricity_annual) is None:
            sf = iscale.get_scaling_factor(
                self.electricity_annual, default=1e-3, warning=True
            )
            iscale.set_scaling_factor(self.electricity_annual, sf)

        if iscale.get_scaling_factor(self.electricity) is None:
            sf = iscale.get_scaling_factor(self.electricity, default=1e-3, warning=True)
            iscale.set_scaling_factor(self.electricity, sf)


    def initialize_build(
        blk,
        outlvl=idaeslog.NOTSET,
        solver=None,
        optarg=None,
    ):
        """
        General wrapper for initialization routines

        Keyword Arguments:
            outlvl : sets output level of initialization routine
            optarg : solver options dictionary object (default=None)
            solver : str indicating which solver to use during
                     initialization (default = None)

        Returns: None
        """
        init_log = idaeslog.getInitLogger(blk.name, outlvl, tag="unit")
        solve_log = idaeslog.getSolveLogger(blk.name, outlvl, tag="unit")

        iscale.calculate_variable_from_constraint(
            blk.heat_annual, blk.surrogate_blk.pysmo_constraint["heat_annual"]
        )
        iscale.calculate_variable_from_constraint(blk.heat_annual, blk.heat_constraint)
        iscale.calculate_variable_from_constraint(
            blk.electricity_annual,
            blk.surrogate_blk.pysmo_constraint["electricity_annual"],
        )

        # Create solver
        opt = get_solver(solver, optarg)

        # Solve unit
        with idaeslog.solver_log(solve_log, idaeslog.DEBUG) as slc:
            res = opt.solve(blk, tee=slc.tee)

        init_log.info_high(f"Initialization Step 2 {idaeslog.condition(res)}")

        if not check_optimal_termination(res):
            raise InitializationError(f"Unit model {self.name} failed to initialize")

        init_log.info("Initialization Complete: {}".format(idaeslog.condition(res)))
